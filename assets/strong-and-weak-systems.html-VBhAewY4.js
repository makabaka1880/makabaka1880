import{_ as h,c as d,g as s,b as n,f as i,d as a,e as l,r as p,o}from"./app-CVkNJmK6.js";const k="/assets/CS/CS-Type-1.webp",c="/assets/CS/CS-Type-2.webp",m="/assets/CS/CS-Type-3.webp",g="/assets/CS/CS-Type-4.webp",y="/assets/CS/CS-Type-5.webp",b={};function u(A,t){const e=p("Anchor"),r=p("NextPage");return o(),d("div",null,[t[9]||(t[9]=s('<h1 id="_0x00-弱类型系统与强类型系统" tabindex="-1"><a class="header-anchor" href="#_0x00-弱类型系统与强类型系统"><span>0x00 弱类型系统与强类型系统</span></a></h1><div class="hint-container tip"><p class="hint-container-title">本节术语</p><ul><li><a href="#implicit-type-casting"><strong>隐式类型转换 (implicit type casting)</strong></a> - 存在于弱类型语言中的特性</li><li><a href="#explicit-type-casting"><strong>显式类型转换 (explicit type casting)</strong></a> - 用户进行的类型转换</li><li><a href="#type-coercion"><strong>强制类型转换 (type coercion)</strong></a> - 符合逻辑下的隐式类型转换</li><li><a href="#type-promotion"><strong>类型提升 (type promotion)</strong></a> - 一种特殊的强制类型转换</li></ul></div><p>JS的类型系统之所以“累心”，根本原因在于它是弱类型系统，类型检查大多发生在程序运行时，而不是编译时。这意味着变量的类型可以随时变化，导致代码行为难以预测，容易出错。</p>',3)),n("p",null,[t[1]||(t[1]=i("弱类型语言有一个特点：那就是会进行")),a(e,{id:"implicit-type-casting"},{default:l(()=>t[0]||(t[0]=[i("隐式类型转换（implicit type casting）")])),_:1}),t[2]||(t[2]=i("："))]),t[10]||(t[10]=s(`<div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;2&#39;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // &#39;22&#39;, int to string conversion then performing string concatenation</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;2&#39;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 0, string to int conversion then performing subtraction</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看很方便，但这会让代码很不可靠。比如我们可以把加法改成减法，从而实现一些奇怪的东西：</p><figure><img src="`+k+'" alt="数学老师哭晕在厕所" tabindex="0" loading="lazy"><figcaption>数学老师哭晕在厕所</figcaption></figure><p>相比之下，python就不会这样:</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;2&#39;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> # TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>刚刚那些诡异的事情也不会发生</p><figure><img src="'+c+`" alt="一点脸也不给" tabindex="0" loading="lazy"><figcaption>一点脸也不给</figcaption></figure><p>我们也可以暂且称python为一个强类型语言。当然，并不是所有类型转换都发生在弱类型语言中。</p><p>当然，不同语言各自有一套逻辑体系，毕竟类型之间并非完全不可转换。比如在数学上，float、double 和 int 之间是可以相互转换的，而且各种数据类型也可以用文字描述。用户一般也会使用这种功能，叫做。</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;32&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># &quot;32&quot; intepreted as integer 32</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">一个小细节</p><p>在 C++ 中，如果执行以下代码：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;a&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) a;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 会返回 0x61</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>很多人可能会觉得这种转换不够“安全”或者“不合理”，甚至认为它应该报错。但实际上，类型转换并不一定要严格遵循高层语义的合理性；在这里，&#39;a&#39; 本质上是 ASCII 表中的第 97 个字符（十六进制为 0x61），因此被转换成对应的整数值是顺理成章的。这种转换更多是底层对内存表示的重新解释，而不是语义层面的“合理”映射。</p></div>`,11)),n("p",null,[t[4]||(t[4]=i("在合乎这套逻辑的情况下，强类型语言也会进行一种类似的操作。它有区别于弱类型语言的隐式转换，叫")),a(e,{id:"type-coercion"},{default:l(()=>t[3]||(t[3]=[i("强制类型转换 (type coercion)")])),_:1}),t[5]||(t[5]=i(" 的操作:"))]),t[11]||(t[11]=s(`<div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">True</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># True (bool) coerced into &quot;True&quot; (str), prints &quot;True&quot; at stdout</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2.1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> # 2 (int) coerced into 2.0 (float), returns 4.1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>再比如在Java中，</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 2 (int) coerced into &quot;2&quot; (String), returns &quot;22&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>也是成立的。与JS不同的是，这种转换是合乎逻辑的：</p><figure><img src="`+m+'" alt="只有拼接有效" tabindex="0" loading="lazy"><figcaption>只有拼接有效</figcaption></figure><p>因为在有字符串出现的时候，java就默认是在做字符串拼接，不会像js一样随机应变，因此也可以看作是合理的强制转换。</p>',6)),n("p",null,[t[7]||(t[7]=i("这种从一个类型转化到另一类型的情况叫做")),a(e,{id:"type-promotion"},{default:l(()=>t[6]||(t[6]=[i("类型提升 (type promotion)")])),_:1}),t[8]||(t[8]=i("。我们分析刚刚提到的2 + 2.1:"))]),t[12]||(t[12]=s('<figure><img src="'+g+`" alt="从到的类型提升" tabindex="0" loading="lazy"><figcaption>从<code>int</code>到<code>double</code>的类型提升</figcaption></figure><p>逻辑上，<code>double</code>（或 <code>float</code>）类型可以看作是实数集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span>，而 <code>int</code> 类型则对应整数集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span>。学过基础数论的同学都知道，整数集是实数集的子集，也就是说 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo>⊂</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\\mathbb{Z} \\subset \\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.728em;vertical-align:-0.0391em;"></span><span class="mord mathbb">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span>。因此，我们可以把将 <code>int</code> 转换为 double 看作是一个从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span> 的映射。</p><div class="hint-container warning"><p class="hint-container-title">提示</p><p>需要注意的是，尽管在数学上整数和对应的实数值是等价的，但在编程语言的类型系统中，<code>int</code> 并不是 <code>double</code> 的子类型（子集），而是两种不同的类型。类型提升就是把一个较小“集合”（离散整数）映射到更大“集合”（连续实数）的过程，从而保证操作的正确性和一致性。</p></div><p>有些语言当中根本就不存在coercion, 例如Haskell。</p><div class="language-haskell line-numbers-mode" data-highlighter="shiki" data-ext="haskell" data-title="haskell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a :: </span><span style="--shiki-light:#A626A4;--shiki-dark:#D19A66;">Int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b :: </span><span style="--shiki-light:#A626A4;--shiki-dark:#D19A66;">Double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">a + b;      </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- Couldn&#39;t match expected type ‘Int’ with actual type ‘Double’</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作为一门完全基于Dependent Type Theory的形式证明语言，Lean需要严格的类型范围限制：</p><figure><img src="`+y+'" alt="lean严格到爆的类型，自然数和非负数都不能直接转换，还得证明" tabindex="0" loading="lazy"><figcaption>lean严格到爆的类型，自然数和非负数都不能直接转换，还得证明</figcaption></figure><p>总体来说，这是大多数的语言类型系统的强弱：</p><table><thead><tr><th>语言</th><th>类型系统</th><th>特点</th></tr></thead><tbody><tr><td>C</td><td>弱类型</td><td>可隐式转换，易出错</td></tr><tr><td>C++</td><td>弱类型</td><td>支持隐式/显式转换</td></tr><tr><td>Java</td><td>强类型</td><td></td></tr><tr><td>C#</td><td>强类型</td><td></td></tr><tr><td>Go</td><td>强类型</td><td></td></tr><tr><td>Rust</td><td>强类型</td><td></td></tr><tr><td>Swift</td><td>强类型</td><td></td></tr><tr><td>Kotlin</td><td>强类型</td><td></td></tr><tr><td>TypeScript</td><td>强类型</td><td></td></tr><tr><td>Python</td><td>强类型</td><td>运行时检查，支持type hint</td></tr><tr><td>Ruby</td><td>强类型</td><td>Duck</td></tr><tr><td>JavaScript</td><td>弱类型</td><td>隐式转换多，易出错</td></tr><tr><td>PHP</td><td>弱类型</td><td>类型灵活，易出错</td></tr><tr><td>Haskell</td><td>强类型</td><td>类型推断，极严格</td></tr><tr><td>Lean</td><td>强类型</td><td></td></tr></tbody></table>',9)),a(r,{title:"动态类型语言与静态类型语言",href:"static-and-dynamic-systems"})])}const x=h(b,[["render",u],["__file","strong-and-weak-systems.html.vue"]]),f=JSON.parse('{"path":"/CS/theoretical/type-theory/type-systems/strong-and-weak-systems.html","title":"0x00 弱类型系统与强类型系统","lang":"zh-CN","frontmatter":{"description":"0x00 弱类型系统与强类型系统 本节术语 隐式类型转换 (implicit type casting) - 存在于弱类型语言中的特性 显式类型转换 (explicit type casting) - 用户进行的类型转换 强制类型转换 (type coercion) - 符合逻辑下的隐式类型转换 类型提升 (type promotion) - 一种特殊...","head":[["meta",{"property":"og:url","content":"https://makabaka1880.xyz/CS/theoretical/type-theory/type-systems/strong-and-weak-systems.html"}],["meta",{"property":"og:site_name","content":"Makabaka1880的博客"}],["meta",{"property":"og:title","content":"0x00 弱类型系统与强类型系统"}],["meta",{"property":"og:description","content":"0x00 弱类型系统与强类型系统 本节术语 隐式类型转换 (implicit type casting) - 存在于弱类型语言中的特性 显式类型转换 (explicit type casting) - 用户进行的类型转换 强制类型转换 (type coercion) - 符合逻辑下的隐式类型转换 类型提升 (type promotion) - 一种特殊..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://makabaka1880.xyz/assets/CS/CS-Type-1.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-05T15:08:25.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-05T15:08:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"0x00 弱类型系统与强类型系统\\",\\"image\\":[\\"https://makabaka1880.xyz/assets/CS/CS-Type-1.webp\\",\\"https://makabaka1880.xyz/assets/CS/CS-Type-2.webp\\",\\"https://makabaka1880.xyz/assets/CS/CS-Type-3.webp\\",\\"https://makabaka1880.xyz/assets/CS/CS-Type-4.webp\\",\\"https://makabaka1880.xyz/assets/CS/CS-Type-5.webp\\"],\\"dateModified\\":\\"2025-07-05T15:08:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Makabaka1880\\",\\"url\\":\\"https://makabaka1880.xyz\\"}]}"]]},"headers":[],"git":{"createdTime":1750154378000,"updatedTime":1751728105000,"contributors":[{"name":"makabaka1880","username":"makabaka1880","email":"makabaka1880@outlook.com","commits":2,"url":"https://github.com/makabaka1880"}]},"readingTime":{"minutes":4.29,"words":1286},"filePathRelative":"CS/theoretical/type-theory/type-systems/strong-and-weak-systems.md","localizedDate":"2025年6月17日","excerpt":"\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">本节术语</p>\\n<ul>\\n<li><a href=\\"#implicit-type-casting\\"><strong>隐式类型转换 (implicit type casting)</strong></a> - 存在于弱类型语言中的特性</li>\\n<li><a href=\\"#explicit-type-casting\\"><strong>显式类型转换 (explicit type casting)</strong></a> - 用户进行的类型转换</li>\\n<li><a href=\\"#type-coercion\\"><strong>强制类型转换 (type coercion)</strong></a> - 符合逻辑下的隐式类型转换</li>\\n<li><a href=\\"#type-promotion\\"><strong>类型提升 (type promotion)</strong></a> - 一种特殊的强制类型转换</li>\\n</ul>\\n</div>","autoDesc":true}');export{x as comp,f as data};
